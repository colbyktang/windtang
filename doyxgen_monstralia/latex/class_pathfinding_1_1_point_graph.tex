\hypertarget{class_pathfinding_1_1_point_graph}{}\doxysection{Pathfinding.\+Point\+Graph Class Reference}
\label{class_pathfinding_1_1_point_graph}\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}}


Basic point graph.  




Inheritance diagram for Pathfinding.\+Point\+Graph\+:
% FIG 0


Collaboration diagram for Pathfinding.\+Point\+Graph\+:
% FIG 1
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a60745b93b227c7bb466d228120ee243f}{Node\+Distance\+Mode}} \{ \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a60745b93b227c7bb466d228120ee243fa6c3a6944a808a7c0bbb6788dbec54a9f}{Node\+Distance\+Mode.\+Node}}, 
\mbox{\hyperlink{class_pathfinding_1_1_point_graph_a60745b93b227c7bb466d228120ee243fac2cc7082a89c1ad6631a2f66af5f00c0}{Node\+Distance\+Mode.\+Connection}}
 \}
\begin{DoxyCompactList}\small\item\em Distance query mode. \mbox{[}Open online documentation to see images\mbox{]} \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
override int \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a2d35175cb678b8fc306e7102c0dc256e}{Count\+Nodes}} ()
\begin{DoxyCompactList}\small\item\em Number of nodes in the graph. Note that this is, unless the graph type has overriden it, an O(n) operation. \end{DoxyCompactList}\item 
override void \mbox{\hyperlink{class_pathfinding_1_1_point_graph_af0a3689dc42b26bcfeb7f0128caebdc9}{Get\+Nodes}} (System.\+Action$<$ \mbox{\hyperlink{class_pathfinding_1_1_graph_node}{Graph\+Node}} $>$ action)
\begin{DoxyCompactList}\small\item\em Calls a delegate with all nodes in the graph. This is the primary way of iterating through all nodes in a graph. \end{DoxyCompactList}\item 
override \mbox{\hyperlink{struct_pathfinding_1_1_n_n_info_internal}{N\+N\+Info\+Internal}} \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a4a989410543a8366adf36101e22b24a4}{Get\+Nearest}} (Vector3 position, \mbox{\hyperlink{class_pathfinding_1_1_n_n_constraint}{N\+N\+Constraint}} constraint, \mbox{\hyperlink{class_pathfinding_1_1_graph_node}{Graph\+Node}} hint)
\begin{DoxyCompactList}\small\item\em Returns the nearest node to a position using the specified \mbox{\hyperlink{class_pathfinding_1_1_n_n_constraint}{N\+N\+Constraint}}. \end{DoxyCompactList}\item 
override \mbox{\hyperlink{struct_pathfinding_1_1_n_n_info_internal}{N\+N\+Info\+Internal}} \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a2aa1aa946b287fc7862018ea55dd434d}{Get\+Nearest\+Force}} (Vector3 position, \mbox{\hyperlink{class_pathfinding_1_1_n_n_constraint}{N\+N\+Constraint}} constraint)
\begin{DoxyCompactList}\small\item\em Returns the nearest node to a position using the specified \mbox{\hyperlink{class_pathfinding_1_1_n_n_constraint}{constraint }}. Returns\+: an \mbox{\hyperlink{struct_pathfinding_1_1_n_n_info}{N\+N\+Info}}. This method will only return an empty \mbox{\hyperlink{struct_pathfinding_1_1_n_n_info}{N\+N\+Info}} if there are no nodes which comply with the specified constraint. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_pathfinding_1_1_point_node}{Point\+Node}} \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a6f99f5447b0d3f42b00680c8e55dda02}{Add\+Node}} (\mbox{\hyperlink{struct_pathfinding_1_1_int3}{Int3}} position)
\begin{DoxyCompactList}\small\item\em Add a node to the graph at the specified position. Note\+: Vector3 can be casted to \mbox{\hyperlink{struct_pathfinding_1_1_int3}{Int3}} using (\mbox{\hyperlink{struct_pathfinding_1_1_int3}{Int3}})my\+Vector. \end{DoxyCompactList}\item 
T \mbox{\hyperlink{class_pathfinding_1_1_point_graph_abf3925f1fd60569e68f2e4737532d989}{Add\+Node$<$ T $>$}} (T node, \mbox{\hyperlink{struct_pathfinding_1_1_int3}{Int3}} position)
\begin{DoxyCompactList}\small\item\em Add a node with the specified type to the graph at the specified position. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a9efe028687c9de672dd8b9c29fe343c2}{Rebuild\+Node\+Lookup}} ()
\begin{DoxyCompactList}\small\item\em Rebuilds the lookup structure for nodes. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_pathfinding_1_1_point_graph_ac75dfbde3dc85238ea2d5304537cbff9}{Rebuild\+Connection\+Distance\+Lookup}} ()
\begin{DoxyCompactList}\small\item\em Rebuilds a cache used when \mbox{\hyperlink{class_pathfinding_1_1_point_graph_ad0862813b3ecd1396ab6aa65f49f3910}{nearest\+Node\+Distance\+Mode}} = Node\+Distance\+Mode.\+To\+Connection \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a43ed88a8538e5a27c6ddf7429adbc79f}{Register\+Connection\+Length}} (long sqr\+Length)
\begin{DoxyCompactList}\small\item\em Ensures the graph knows that there is a connection with this length. This is used when the nearest node distance mode is set to To\+Connection. If you are modifying node connections yourself (i.\+e. manipulating the \mbox{\hyperlink{class_pathfinding_1_1_point_node_a1f67328ec333033d077b31e8d3edef3f}{Point\+Node.\+connections}} array) then you must call this function when you add any connections. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a196e172067978f857152b90702c53579}{Connect\+Nodes}} ()
\begin{DoxyCompactList}\small\item\em Recalculates connections for all nodes in the graph. This is useful if you have created nodes manually using \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a6f99f5447b0d3f42b00680c8e55dda02}{Add\+Node}} and then want to connect them in the same way as the point graph normally connects nodes. \end{DoxyCompactList}\item 
virtual bool \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a27f8a606c77dac285032529e633716fb}{Is\+Valid\+Connection}} (\mbox{\hyperlink{class_pathfinding_1_1_graph_node}{Graph\+Node}} a, \mbox{\hyperlink{class_pathfinding_1_1_graph_node}{Graph\+Node}} b, out float dist)
\begin{DoxyCompactList}\small\item\em Returns if the connection between a and b is valid. Checks for obstructions using raycasts (if enabled) and checks for height differences.~\newline
As a bonus, it outputs the distance between the nodes too if the connection is valid. \end{DoxyCompactList}\item 
override void \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a68b9cde25f35de4629d26b0aaea10324}{Relocate\+Nodes}} (Matrix4x4 delta\+Matrix)
\begin{DoxyCompactList}\small\item\em Moves the nodes in this graph. Multiplies all node positions by delta\+Matrix. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
Transform \mbox{\hyperlink{class_pathfinding_1_1_point_graph_af12e3973b6126d65120b04891595f9e9}{root}}
\begin{DoxyCompactList}\small\item\em Childs of this transform are treated as nodes \end{DoxyCompactList}\item 
string \mbox{\hyperlink{class_pathfinding_1_1_point_graph_ab8f69c9b8adbd494054f9badc06c6bce}{search\+Tag}}
\begin{DoxyCompactList}\small\item\em If no \mbox{\hyperlink{class_pathfinding_1_1_point_graph_af12e3973b6126d65120b04891595f9e9}{root}} is set, all nodes with the tag is used as nodes \end{DoxyCompactList}\item 
float \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a7874788b8962f2068f7e6a477dcbb54d}{max\+Distance}}
\begin{DoxyCompactList}\small\item\em Max distance for a connection to be valid. The value 0 (zero) will be read as infinity and thus all nodes not restricted by other constraints will be added as connections. \end{DoxyCompactList}\item 
Vector3 \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a1ae03e9b05c144579a5460baa36a7be7}{limits}}
\begin{DoxyCompactList}\small\item\em Max distance along the axis for a connection to be valid. 0 = infinity \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a08e9052cc4fe68c447d9376fd335af95}{raycast}} = true
\begin{DoxyCompactList}\small\item\em Use raycasts to check connections \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_pathfinding_1_1_point_graph_ac5bcd5a9d07beca7956657a067597da5}{use2\+D\+Physics}}
\begin{DoxyCompactList}\small\item\em Use the 2D Physics A\+PI \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a191d25a134c7891668b98da78ab06ac9}{thick\+Raycast}}
\begin{DoxyCompactList}\small\item\em Use thick raycast \end{DoxyCompactList}\item 
float \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a8b80ca07f77c012aafe4171d55fd917c}{thick\+Raycast\+Radius}} = 1
\begin{DoxyCompactList}\small\item\em Thick raycast radius \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_pathfinding_1_1_point_graph_ada935a5bb9e71d2b5db0a85c7909e1bd}{recursive}} = true
\begin{DoxyCompactList}\small\item\em Recursively search for child nodes to the \mbox{\hyperlink{class_pathfinding_1_1_point_graph_af12e3973b6126d65120b04891595f9e9}{root}} \end{DoxyCompactList}\item 
Layer\+Mask \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a14323c414a3c37c1f859a19c06d374db}{mask}}
\begin{DoxyCompactList}\small\item\em Layer mask to use for raycast \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_pathfinding_1_1_point_node}{Point\+Node}}\mbox{[}$\,$\mbox{]} \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a1e6a8498de32d784d5b1e98fed0e5aa7}{nodes}}
\begin{DoxyCompactList}\small\item\em All nodes in this graph. Note that only the first \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a45b5ab0eabfd072e976437ce3103d868}{node\+Count}} will be non-\/null. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_pathfinding_1_1_point_graph_a60745b93b227c7bb466d228120ee243f}{Node\+Distance\+Mode}} \mbox{\hyperlink{class_pathfinding_1_1_point_graph_ad0862813b3ecd1396ab6aa65f49f3910}{nearest\+Node\+Distance\+Mode}}
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a8a47f990f66c5a3d97aecf149b5d0f3a}{Add\+Children}} (ref int c, Transform tr)
\begin{DoxyCompactList}\small\item\em Recursively adds childrens of a transform as nodes \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a6e952d8e9eae0753f48873801b6058d7}\label{class_pathfinding_1_1_point_graph_a6e952d8e9eae0753f48873801b6058d7}} 
virtual \mbox{\hyperlink{class_pathfinding_1_1_point_node}{Point\+Node}}\mbox{[}$\,$\mbox{]} {\bfseries Create\+Nodes} (int count)
\item 
override I\+Enumerable$<$ \mbox{\hyperlink{struct_pathfinding_1_1_progress}{Progress}} $>$ \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a2ace5ae862dbc7d461b6c7c9fbc1b37b}{Scan\+Internal}} ()
\begin{DoxyCompactList}\small\item\em Internal method to scan the graph. Called from \mbox{\hyperlink{class_astar_path_ace889f7d491b7100be4db339466880e4}{Astar\+Path.\+Scan\+Async}}. Override this function to implement custom scanning logic. \mbox{\hyperlink{struct_pathfinding_1_1_progress}{Progress}} objects can be yielded to show progress info in the editor and to split up processing over several frames when using async scanning. \end{DoxyCompactList}\item 
override void \mbox{\hyperlink{class_pathfinding_1_1_point_graph_ab1a971495a3f3638b5253e125d217657}{Post\+Deserialization}} (\mbox{\hyperlink{class_pathfinding_1_1_serialization_1_1_graph_serialization_context}{Graph\+Serialization\+Context}} ctx)
\begin{DoxyCompactList}\small\item\em Called after all deserialization has been done for all graphs. Can be used to set up more graph data which is not serialized \end{DoxyCompactList}\item 
override void \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a565b855a95b4f7bdeb20411ae086aa59}{Deserialize\+Settings\+Compatibility}} (\mbox{\hyperlink{class_pathfinding_1_1_serialization_1_1_graph_serialization_context}{Graph\+Serialization\+Context}} ctx)
\begin{DoxyCompactList}\small\item\em An old format for serializing settings. Deprecated\+: This is deprecated now, but the deserialization code is kept to avoid loosing data when upgrading from older versions. \end{DoxyCompactList}\item 
override void \mbox{\hyperlink{class_pathfinding_1_1_point_graph_acc10dd8e03e6c34debff2df840ae4a4c}{Serialize\+Extra\+Info}} (\mbox{\hyperlink{class_pathfinding_1_1_serialization_1_1_graph_serialization_context}{Graph\+Serialization\+Context}} ctx)
\begin{DoxyCompactList}\small\item\em Serializes graph type specific node data. This function can be overriden to serialize extra node information (or graph information for that matter) which cannot be serialized using the standard serialization. Serialize the data in any way you want and return a byte array. When loading, the exact same byte array will be passed to the Deserialize\+Extra\+Info function.~\newline
These functions will only be called if node serialization is enabled.~\newline
\end{DoxyCompactList}\item 
override void \mbox{\hyperlink{class_pathfinding_1_1_point_graph_ae7e7ab04e795f2d57b830d174c1c9a3f}{Deserialize\+Extra\+Info}} (\mbox{\hyperlink{class_pathfinding_1_1_serialization_1_1_graph_serialization_context}{Graph\+Serialization\+Context}} ctx)
\begin{DoxyCompactList}\small\item\em Deserializes graph type specific node data. See\+: Serialize\+Extra\+Info \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
static int \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a4537c6002eef998cd229a3b05af74dc5}{Count\+Children}} (Transform tr)
\begin{DoxyCompactList}\small\item\em Recursively counds children of a transform \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Properties}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a45b5ab0eabfd072e976437ce3103d868}{node\+Count}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, protected set\mbox{]}}
\begin{DoxyCompactList}\small\item\em Number of nodes in this graph \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Basic point graph. 

The point graph is the most basic graph structure, it consists of a number of interconnected points in space called nodes or waypoints.~\newline
The point graph takes a Transform object as \char`\"{}root\char`\"{}, this Transform will be searched for child objects, every child object will be treated as a node. If \mbox{\hyperlink{class_pathfinding_1_1_point_graph_ada935a5bb9e71d2b5db0a85c7909e1bd}{recursive}} is enabled, it will also search the child objects of the children recursively. It will then check if any connections between the nodes can be made, first it will check if the distance between the nodes isn\textquotesingle{}t too large (max\+Distance) and then it will check if the axis aligned distance isn\textquotesingle{}t too high. The axis aligned distance, named \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a1ae03e9b05c144579a5460baa36a7be7}{limits}}, is useful because usually an AI cannot climb very high, but linking nodes far away from each other, but on the same Y level should still be possible. \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a1ae03e9b05c144579a5460baa36a7be7}{limits}} and \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a7874788b8962f2068f7e6a477dcbb54d}{max\+Distance}} are treated as being set to infinity if they are set to 0 (zero). ~\newline
Lastly it will check if there are any obstructions between the nodes using \href{http://unity3d.com/support/documentation/ScriptReference/Physics.Raycast.html}{\texttt{ raycasting}} which can optionally be thick.~\newline
One thing to think about when using raycasting is to either place the nodes a small distance above the ground in your scene or to make sure that the ground is not in the raycast mask to avoid the raycast from hitting the ground.~\newline
 Alternatively, a tag can be used to search for nodes. See\+: \href{http://docs.unity3d.com/Manual/Tags.html}{\texttt{ http\+://docs.\+unity3d.\+com/\+Manual/\+Tags.\+html}}

For larger graphs, it can take quite some time to scan the graph with the default settings. If you have the pro version you can enable optimize\+For\+Sparse\+Graph which will in most cases reduce the calculation times drastically.

Note\+: Does not support linecast because of obvious reasons.

\mbox{[}Open online documentation to see images\mbox{]} \mbox{[}Open online documentation to see images\mbox{]}

\doxysubsection{Member Enumeration Documentation}
\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a60745b93b227c7bb466d228120ee243f}\label{class_pathfinding_1_1_point_graph_a60745b93b227c7bb466d228120ee243f}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!NodeDistanceMode@{NodeDistanceMode}}
\index{NodeDistanceMode@{NodeDistanceMode}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{NodeDistanceMode}{NodeDistanceMode}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a60745b93b227c7bb466d228120ee243f}{Pathfinding.\+Point\+Graph.\+Node\+Distance\+Mode}}\hspace{0.3cm}{\ttfamily [strong]}}



Distance query mode. \mbox{[}Open online documentation to see images\mbox{]} 

In the image above there are a few red nodes. Assume the agent is the orange circle. Using the Node mode the closest point on the graph that would be found would be the node at the bottom center which may not be what you want. Using the Connection mode it will find the closest point on the connection between the two nodes in the top half of the image.

When using the Connection option you may also want to use the Connection option for the \mbox{\hyperlink{class_pathfinding_1_1_seeker}{Seeker}}\textquotesingle{}s Start End Modifier snapping options. This is not strictly necessary, but it most cases it is what you want.

See\+: \mbox{\hyperlink{class_pathfinding_1_1_start_end_modifier_a1a75266e70c393d320cb797c304e9274}{Pathfinding.\+Start\+End\+Modifier.\+exact\+End\+Point}}\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{Node@{Node}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!Node@{Node}}}\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a60745b93b227c7bb466d228120ee243fa6c3a6944a808a7c0bbb6788dbec54a9f}\label{class_pathfinding_1_1_point_graph_a60745b93b227c7bb466d228120ee243fa6c3a6944a808a7c0bbb6788dbec54a9f}} 
Node&All nearest node queries find the closest node center. This is the fastest option but it may not be what you want if you have long connections. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{Connection@{Connection}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!Connection@{Connection}}}\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a60745b93b227c7bb466d228120ee243fac2cc7082a89c1ad6631a2f66af5f00c0}\label{class_pathfinding_1_1_point_graph_a60745b93b227c7bb466d228120ee243fac2cc7082a89c1ad6631a2f66af5f00c0}} 
Connection&All nearest node queries find the closest point on edges between nodes. This is useful if you have long connections where the agent might be closer to some unrelated node if it is standing on a long connection between two nodes. This mode is however slower than the Node mode. \\
\hline

\end{DoxyEnumFields}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a8a47f990f66c5a3d97aecf149b5d0f3a}\label{class_pathfinding_1_1_point_graph_a8a47f990f66c5a3d97aecf149b5d0f3a}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!AddChildren@{AddChildren}}
\index{AddChildren@{AddChildren}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{AddChildren()}{AddChildren()}}
{\footnotesize\ttfamily void Pathfinding.\+Point\+Graph.\+Add\+Children (\begin{DoxyParamCaption}\item[{ref int}]{c,  }\item[{Transform}]{tr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}



Recursively adds childrens of a transform as nodes 

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a6f99f5447b0d3f42b00680c8e55dda02}\label{class_pathfinding_1_1_point_graph_a6f99f5447b0d3f42b00680c8e55dda02}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!AddNode@{AddNode}}
\index{AddNode@{AddNode}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{AddNode()}{AddNode()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_pathfinding_1_1_point_node}{Point\+Node}} Pathfinding.\+Point\+Graph.\+Add\+Node (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_pathfinding_1_1_int3}{Int3}}}]{position }\end{DoxyParamCaption})}



Add a node to the graph at the specified position. Note\+: Vector3 can be casted to \mbox{\hyperlink{struct_pathfinding_1_1_int3}{Int3}} using (\mbox{\hyperlink{struct_pathfinding_1_1_int3}{Int3}})my\+Vector. 

Note\+: This needs to be called when it is safe to update nodes, which is
\begin{DoxyItemize}
\item when scanning
\item during a graph update
\item inside a callback registered using \mbox{\hyperlink{class_astar_path_ae285a59790c68b9b7e0e2964103418f9}{Astar\+Path.\+Add\+Work\+Item}}
\end{DoxyItemize}

{\ttfamily  Astar\+Path.\+active.\+Add\+Work\+Item(new \mbox{\hyperlink{struct_pathfinding_1_1_astar_work_item}{Astar\+Work\+Item}}(ctx =$>$ \{ var graph = Astar\+Path.\+active.\+data.\+point\+Graph; // Add 2 nodes and connect them var node1 = graph.\+Add\+Node((\mbox{\hyperlink{struct_pathfinding_1_1_int3}{Int3}})transform.\+position); var node2 = graph.\+Add\+Node((\mbox{\hyperlink{struct_pathfinding_1_1_int3}{Int3}})(transform.\+position + Vector3.\+right)); var cost = (uint)(node2.\+position -\/ node1.\+position).cost\+Magnitude; node1.\+Add\+Connection(node2, cost); node2.\+Add\+Connection(node1, cost); \})); }

See\+: runtime-\/graphs (view in online documentation for working links)\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_abf3925f1fd60569e68f2e4737532d989}\label{class_pathfinding_1_1_point_graph_abf3925f1fd60569e68f2e4737532d989}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!AddNode$<$ T $>$@{AddNode$<$ T $>$}}
\index{AddNode$<$ T $>$@{AddNode$<$ T $>$}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{AddNode$<$ T $>$()}{AddNode< T >()}}
{\footnotesize\ttfamily T \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a6f99f5447b0d3f42b00680c8e55dda02}{Pathfinding.\+Point\+Graph.\+Add\+Node}}$<$ T $>$ (\begin{DoxyParamCaption}\item[{T}]{node,  }\item[{\mbox{\hyperlink{struct_pathfinding_1_1_int3}{Int3}}}]{position }\end{DoxyParamCaption})}



Add a node with the specified type to the graph at the specified position. 

Note\+: Vector3 can be casted to \mbox{\hyperlink{struct_pathfinding_1_1_int3}{Int3}} using (\mbox{\hyperlink{struct_pathfinding_1_1_int3}{Int3}})my\+Vector.

Note\+: This needs to be called when it is safe to update nodes, which is
\begin{DoxyItemize}
\item when scanning
\item during a graph update
\item inside a callback registered using \mbox{\hyperlink{class_astar_path_ae285a59790c68b9b7e0e2964103418f9}{Astar\+Path.\+Add\+Work\+Item}}
\end{DoxyItemize}

See\+: \mbox{\hyperlink{class_astar_path_ae285a59790c68b9b7e0e2964103418f9}{Astar\+Path.\+Add\+Work\+Item}} See\+: runtime-\/graphs (view in online documentation for working links)


\begin{DoxyParams}{Parameters}
{\em node} & This must be a node created using T(\mbox{\hyperlink{class_astar_path_a93828f3873280d7b2db847f69392b5fd}{Astar\+Path.\+active}}) right before the call to this method. The node parameter is only there because there is no new(\+Astar\+Path) constraint on generic type parameters.\\
\hline
{\em position} & The node will be set to this position.\\
\hline
\end{DoxyParams}
\begin{Desc}
\item[Type Constraints]\begin{description}
\item[{\em T} : {\em Point\+Node}]\end{description}
\end{Desc}
\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a196e172067978f857152b90702c53579}\label{class_pathfinding_1_1_point_graph_a196e172067978f857152b90702c53579}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!ConnectNodes@{ConnectNodes}}
\index{ConnectNodes@{ConnectNodes}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{ConnectNodes()}{ConnectNodes()}}
{\footnotesize\ttfamily void Pathfinding.\+Point\+Graph.\+Connect\+Nodes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Recalculates connections for all nodes in the graph. This is useful if you have created nodes manually using \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a6f99f5447b0d3f42b00680c8e55dda02}{Add\+Node}} and then want to connect them in the same way as the point graph normally connects nodes. 

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a4537c6002eef998cd229a3b05af74dc5}\label{class_pathfinding_1_1_point_graph_a4537c6002eef998cd229a3b05af74dc5}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!CountChildren@{CountChildren}}
\index{CountChildren@{CountChildren}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{CountChildren()}{CountChildren()}}
{\footnotesize\ttfamily static int Pathfinding.\+Point\+Graph.\+Count\+Children (\begin{DoxyParamCaption}\item[{Transform}]{tr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}}



Recursively counds children of a transform 

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a2d35175cb678b8fc306e7102c0dc256e}\label{class_pathfinding_1_1_point_graph_a2d35175cb678b8fc306e7102c0dc256e}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!CountNodes@{CountNodes}}
\index{CountNodes@{CountNodes}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{CountNodes()}{CountNodes()}}
{\footnotesize\ttfamily override int Pathfinding.\+Point\+Graph.\+Count\+Nodes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Number of nodes in the graph. Note that this is, unless the graph type has overriden it, an O(n) operation. 

This is an O(1) operation for grid graphs and point graphs. For layered grid graphs it is an O(n) operation.

Reimplemented from \mbox{\hyperlink{class_pathfinding_1_1_nav_graph_a8a16a2a7653e1420cf4863371782b7e9}{Pathfinding.\+Nav\+Graph}}.

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_ae7e7ab04e795f2d57b830d174c1c9a3f}\label{class_pathfinding_1_1_point_graph_ae7e7ab04e795f2d57b830d174c1c9a3f}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!DeserializeExtraInfo@{DeserializeExtraInfo}}
\index{DeserializeExtraInfo@{DeserializeExtraInfo}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{DeserializeExtraInfo()}{DeserializeExtraInfo()}}
{\footnotesize\ttfamily override void Pathfinding.\+Point\+Graph.\+Deserialize\+Extra\+Info (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_pathfinding_1_1_serialization_1_1_graph_serialization_context}{Graph\+Serialization\+Context}}}]{ctx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



Deserializes graph type specific node data. See\+: Serialize\+Extra\+Info 



Reimplemented from \mbox{\hyperlink{class_pathfinding_1_1_nav_graph_a744eaabc0d215427dbaa72cb431ac635}{Pathfinding.\+Nav\+Graph}}.

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a565b855a95b4f7bdeb20411ae086aa59}\label{class_pathfinding_1_1_point_graph_a565b855a95b4f7bdeb20411ae086aa59}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!DeserializeSettingsCompatibility@{DeserializeSettingsCompatibility}}
\index{DeserializeSettingsCompatibility@{DeserializeSettingsCompatibility}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{DeserializeSettingsCompatibility()}{DeserializeSettingsCompatibility()}}
{\footnotesize\ttfamily override void Pathfinding.\+Point\+Graph.\+Deserialize\+Settings\+Compatibility (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_pathfinding_1_1_serialization_1_1_graph_serialization_context}{Graph\+Serialization\+Context}}}]{ctx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



An old format for serializing settings. Deprecated\+: This is deprecated now, but the deserialization code is kept to avoid loosing data when upgrading from older versions. 



Reimplemented from \mbox{\hyperlink{class_pathfinding_1_1_nav_graph_a72bf5ffc375940c938f31accb8e1d02a}{Pathfinding.\+Nav\+Graph}}.

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a4a989410543a8366adf36101e22b24a4}\label{class_pathfinding_1_1_point_graph_a4a989410543a8366adf36101e22b24a4}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!GetNearest@{GetNearest}}
\index{GetNearest@{GetNearest}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{GetNearest()}{GetNearest()}}
{\footnotesize\ttfamily override \mbox{\hyperlink{struct_pathfinding_1_1_n_n_info_internal}{N\+N\+Info\+Internal}} Pathfinding.\+Point\+Graph.\+Get\+Nearest (\begin{DoxyParamCaption}\item[{Vector3}]{position,  }\item[{\mbox{\hyperlink{class_pathfinding_1_1_n_n_constraint}{N\+N\+Constraint}}}]{constraint,  }\item[{\mbox{\hyperlink{class_pathfinding_1_1_graph_node}{Graph\+Node}}}]{hint }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Returns the nearest node to a position using the specified \mbox{\hyperlink{class_pathfinding_1_1_n_n_constraint}{N\+N\+Constraint}}. 


\begin{DoxyParams}{Parameters}
{\em position} & The position to try to find a close node to\\
\hline
{\em hint} & Can be passed to enable some graph generators to find the nearest node faster.\\
\hline
{\em constraint} & Can for example tell the function to try to return a walkable node. If you do not get a good node back, consider calling Get\+Nearest\+Force.\\
\hline
\end{DoxyParams}


Reimplemented from \mbox{\hyperlink{class_pathfinding_1_1_nav_graph_a75522d1273f1c06c49c1aa951a459b77}{Pathfinding.\+Nav\+Graph}}.

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a2aa1aa946b287fc7862018ea55dd434d}\label{class_pathfinding_1_1_point_graph_a2aa1aa946b287fc7862018ea55dd434d}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!GetNearestForce@{GetNearestForce}}
\index{GetNearestForce@{GetNearestForce}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{GetNearestForce()}{GetNearestForce()}}
{\footnotesize\ttfamily override \mbox{\hyperlink{struct_pathfinding_1_1_n_n_info_internal}{N\+N\+Info\+Internal}} Pathfinding.\+Point\+Graph.\+Get\+Nearest\+Force (\begin{DoxyParamCaption}\item[{Vector3}]{position,  }\item[{\mbox{\hyperlink{class_pathfinding_1_1_n_n_constraint}{N\+N\+Constraint}}}]{constraint }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Returns the nearest node to a position using the specified \mbox{\hyperlink{class_pathfinding_1_1_n_n_constraint}{constraint }}. Returns\+: an \mbox{\hyperlink{struct_pathfinding_1_1_n_n_info}{N\+N\+Info}}. This method will only return an empty \mbox{\hyperlink{struct_pathfinding_1_1_n_n_info}{N\+N\+Info}} if there are no nodes which comply with the specified constraint. 



Reimplemented from \mbox{\hyperlink{class_pathfinding_1_1_nav_graph_a7f8d00bf59f014706eabe25c2b0b7ad4}{Pathfinding.\+Nav\+Graph}}.

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_af0a3689dc42b26bcfeb7f0128caebdc9}\label{class_pathfinding_1_1_point_graph_af0a3689dc42b26bcfeb7f0128caebdc9}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!GetNodes@{GetNodes}}
\index{GetNodes@{GetNodes}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{GetNodes()}{GetNodes()}}
{\footnotesize\ttfamily override void Pathfinding.\+Point\+Graph.\+Get\+Nodes (\begin{DoxyParamCaption}\item[{System.\+Action$<$ \mbox{\hyperlink{class_pathfinding_1_1_graph_node}{Graph\+Node}} $>$}]{action }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Calls a delegate with all nodes in the graph. This is the primary way of iterating through all nodes in a graph. 

Do not change the graph structure inside the delegate.

{\ttfamily  var gg = Astar\+Path.\+active.\+data.\+grid\+Graph;}

{\ttfamily gg.\+Get\+Nodes(node =$>$ \{ // Here is a node Debug.\+Log(\char`\"{}\+I found a node at position \char`\"{} + (Vector3)node.\+position); \}); }

If you want to store all nodes in a list you can do this

{\ttfamily  var gg = Astar\+Path.\+active.\+data.\+grid\+Graph;}

{\ttfamily List$<$\+Graph\+Node$>$ nodes = new List$<$\+Graph\+Node$>$(); gg.\+Get\+Nodes((System.\+Action$<$\+Graph\+Node$>$)nodes.\+Add); }

See\+: \mbox{\hyperlink{class_pathfinding_1_1_astar_data_a21b0e75ff4aa8af66025f06684f4e6df}{Pathfinding.\+Astar\+Data.\+Get\+Nodes}}

Implements \mbox{\hyperlink{class_pathfinding_1_1_nav_graph_a1f30352703d9a3f192d6e6b44d86c8b3}{Pathfinding.\+Nav\+Graph}}.

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a27f8a606c77dac285032529e633716fb}\label{class_pathfinding_1_1_point_graph_a27f8a606c77dac285032529e633716fb}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!IsValidConnection@{IsValidConnection}}
\index{IsValidConnection@{IsValidConnection}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{IsValidConnection()}{IsValidConnection()}}
{\footnotesize\ttfamily virtual bool Pathfinding.\+Point\+Graph.\+Is\+Valid\+Connection (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_pathfinding_1_1_graph_node}{Graph\+Node}}}]{a,  }\item[{\mbox{\hyperlink{class_pathfinding_1_1_graph_node}{Graph\+Node}}}]{b,  }\item[{out float}]{dist }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Returns if the connection between a and b is valid. Checks for obstructions using raycasts (if enabled) and checks for height differences.~\newline
As a bonus, it outputs the distance between the nodes too if the connection is valid. 

Note\+: This is not the same as checking if node a is connected to node b. That should be done using a.\+Contains\+Connection(b)\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_ab1a971495a3f3638b5253e125d217657}\label{class_pathfinding_1_1_point_graph_ab1a971495a3f3638b5253e125d217657}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!PostDeserialization@{PostDeserialization}}
\index{PostDeserialization@{PostDeserialization}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{PostDeserialization()}{PostDeserialization()}}
{\footnotesize\ttfamily override void Pathfinding.\+Point\+Graph.\+Post\+Deserialization (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_pathfinding_1_1_serialization_1_1_graph_serialization_context}{Graph\+Serialization\+Context}}}]{ctx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



Called after all deserialization has been done for all graphs. Can be used to set up more graph data which is not serialized 



Reimplemented from \mbox{\hyperlink{class_pathfinding_1_1_nav_graph_a4f22c1d0267887f4430686d0015c97c6}{Pathfinding.\+Nav\+Graph}}.

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_ac75dfbde3dc85238ea2d5304537cbff9}\label{class_pathfinding_1_1_point_graph_ac75dfbde3dc85238ea2d5304537cbff9}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!RebuildConnectionDistanceLookup@{RebuildConnectionDistanceLookup}}
\index{RebuildConnectionDistanceLookup@{RebuildConnectionDistanceLookup}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{RebuildConnectionDistanceLookup()}{RebuildConnectionDistanceLookup()}}
{\footnotesize\ttfamily void Pathfinding.\+Point\+Graph.\+Rebuild\+Connection\+Distance\+Lookup (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Rebuilds a cache used when \mbox{\hyperlink{class_pathfinding_1_1_point_graph_ad0862813b3ecd1396ab6aa65f49f3910}{nearest\+Node\+Distance\+Mode}} = Node\+Distance\+Mode.\+To\+Connection 

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a9efe028687c9de672dd8b9c29fe343c2}\label{class_pathfinding_1_1_point_graph_a9efe028687c9de672dd8b9c29fe343c2}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!RebuildNodeLookup@{RebuildNodeLookup}}
\index{RebuildNodeLookup@{RebuildNodeLookup}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{RebuildNodeLookup()}{RebuildNodeLookup()}}
{\footnotesize\ttfamily void Pathfinding.\+Point\+Graph.\+Rebuild\+Node\+Lookup (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Rebuilds the lookup structure for nodes. 

This is used when optimize\+For\+Sparse\+Graph is enabled.

You should call this method every time you move a node in the graph manually and you are using optimize\+For\+Sparse\+Graph, otherwise pathfinding might not work correctly.

You may also call this after you have added many nodes using the \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a6f99f5447b0d3f42b00680c8e55dda02}{Add\+Node}} method. When adding nodes using the \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a6f99f5447b0d3f42b00680c8e55dda02}{Add\+Node}} method they will be added to the lookup structure. The lookup structure will rebalance itself when it gets too unbalanced however if you are sure you won\textquotesingle{}t be adding any more nodes in the short term, you can make sure it is perfectly balanced and thus squeeze out the last bit of performance by calling this method. This can improve the performance of the \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a4a989410543a8366adf36101e22b24a4}{Get\+Nearest}} method slightly. The improvements are on the order of 10-\/20\%.\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a43ed88a8538e5a27c6ddf7429adbc79f}\label{class_pathfinding_1_1_point_graph_a43ed88a8538e5a27c6ddf7429adbc79f}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!RegisterConnectionLength@{RegisterConnectionLength}}
\index{RegisterConnectionLength@{RegisterConnectionLength}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{RegisterConnectionLength()}{RegisterConnectionLength()}}
{\footnotesize\ttfamily void Pathfinding.\+Point\+Graph.\+Register\+Connection\+Length (\begin{DoxyParamCaption}\item[{long}]{sqr\+Length }\end{DoxyParamCaption})}



Ensures the graph knows that there is a connection with this length. This is used when the nearest node distance mode is set to To\+Connection. If you are modifying node connections yourself (i.\+e. manipulating the \mbox{\hyperlink{class_pathfinding_1_1_point_node_a1f67328ec333033d077b31e8d3edef3f}{Point\+Node.\+connections}} array) then you must call this function when you add any connections. 

When using \mbox{\hyperlink{class_pathfinding_1_1_point_node_aa11a6a4f935560e774dccfc519038231}{Point\+Node.\+Add\+Connection}} this is done automatically. It is also done for all nodes when \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a9efe028687c9de672dd8b9c29fe343c2}{Rebuild\+Node\+Lookup}} is called.


\begin{DoxyParams}{Parameters}
{\em sqr\+Length} & The length of the connection in squared \mbox{\hyperlink{struct_pathfinding_1_1_int3}{Int3}} units. This can be calculated using (node1.\+position -\/ node2.\+position).sqr\+Magnitude\+Long.\\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a68b9cde25f35de4629d26b0aaea10324}\label{class_pathfinding_1_1_point_graph_a68b9cde25f35de4629d26b0aaea10324}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!RelocateNodes@{RelocateNodes}}
\index{RelocateNodes@{RelocateNodes}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{RelocateNodes()}{RelocateNodes()}}
{\footnotesize\ttfamily override void Pathfinding.\+Point\+Graph.\+Relocate\+Nodes (\begin{DoxyParamCaption}\item[{Matrix4x4}]{delta\+Matrix }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}



Moves the nodes in this graph. Multiplies all node positions by delta\+Matrix. 

For example if you want to move all your nodes in e.\+g a point graph 10 units along the X axis from the initial position {\ttfamily  var graph = Astar\+Path.\+data.\+point\+Graph; var m = Matrix4x4.\+T\+RS (new Vector3(10,0,0), Quaternion.\+identity, Vector3.\+one); graph.\+Relocate\+Nodes (m); }

Note\+: For grid graphs, navmesh graphs and recast graphs it is recommended to use their custom overloads of the Relocate\+Nodes method which take parameters for e.\+g center and node\+Size (and additional parameters) instead since they are both easier to use and are less likely to mess up pathfinding.

Warning\+: This method is lossy for Point\+Graphs, so calling it many times may cause node positions to lose precision. For example if you set the scale to 0 in one call then all nodes will be scaled/moved to the same point and you will not be able to recover their original positions. The same thing happens for other -\/ less extreme -\/ values as well, but to a lesser degree.

Reimplemented from \mbox{\hyperlink{class_pathfinding_1_1_nav_graph_a9418ded2d0b1003b001cecd12da8a73a}{Pathfinding.\+Nav\+Graph}}.

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a2ace5ae862dbc7d461b6c7c9fbc1b37b}\label{class_pathfinding_1_1_point_graph_a2ace5ae862dbc7d461b6c7c9fbc1b37b}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!ScanInternal@{ScanInternal}}
\index{ScanInternal@{ScanInternal}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{ScanInternal()}{ScanInternal()}}
{\footnotesize\ttfamily override I\+Enumerable$<$\mbox{\hyperlink{struct_pathfinding_1_1_progress}{Progress}}$>$ Pathfinding.\+Point\+Graph.\+Scan\+Internal (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



Internal method to scan the graph. Called from \mbox{\hyperlink{class_astar_path_ace889f7d491b7100be4db339466880e4}{Astar\+Path.\+Scan\+Async}}. Override this function to implement custom scanning logic. \mbox{\hyperlink{struct_pathfinding_1_1_progress}{Progress}} objects can be yielded to show progress info in the editor and to split up processing over several frames when using async scanning. 



Implements \mbox{\hyperlink{class_pathfinding_1_1_nav_graph_a98ea7af57e744d11545181ff265c6abe}{Pathfinding.\+Nav\+Graph}}.

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_acc10dd8e03e6c34debff2df840ae4a4c}\label{class_pathfinding_1_1_point_graph_acc10dd8e03e6c34debff2df840ae4a4c}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!SerializeExtraInfo@{SerializeExtraInfo}}
\index{SerializeExtraInfo@{SerializeExtraInfo}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{SerializeExtraInfo()}{SerializeExtraInfo()}}
{\footnotesize\ttfamily override void Pathfinding.\+Point\+Graph.\+Serialize\+Extra\+Info (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_pathfinding_1_1_serialization_1_1_graph_serialization_context}{Graph\+Serialization\+Context}}}]{ctx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



Serializes graph type specific node data. This function can be overriden to serialize extra node information (or graph information for that matter) which cannot be serialized using the standard serialization. Serialize the data in any way you want and return a byte array. When loading, the exact same byte array will be passed to the Deserialize\+Extra\+Info function.~\newline
These functions will only be called if node serialization is enabled.~\newline




Reimplemented from \mbox{\hyperlink{class_pathfinding_1_1_nav_graph_abc97e0461bddc710397f650be9461108}{Pathfinding.\+Nav\+Graph}}.



\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a1ae03e9b05c144579a5460baa36a7be7}\label{class_pathfinding_1_1_point_graph_a1ae03e9b05c144579a5460baa36a7be7}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!limits@{limits}}
\index{limits@{limits}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{limits}{limits}}
{\footnotesize\ttfamily Vector3 Pathfinding.\+Point\+Graph.\+limits}



Max distance along the axis for a connection to be valid. 0 = infinity 

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a14323c414a3c37c1f859a19c06d374db}\label{class_pathfinding_1_1_point_graph_a14323c414a3c37c1f859a19c06d374db}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!mask@{mask}}
\index{mask@{mask}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{mask}{mask}}
{\footnotesize\ttfamily Layer\+Mask Pathfinding.\+Point\+Graph.\+mask}



Layer mask to use for raycast 

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a7874788b8962f2068f7e6a477dcbb54d}\label{class_pathfinding_1_1_point_graph_a7874788b8962f2068f7e6a477dcbb54d}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!maxDistance@{maxDistance}}
\index{maxDistance@{maxDistance}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{maxDistance}{maxDistance}}
{\footnotesize\ttfamily float Pathfinding.\+Point\+Graph.\+max\+Distance}



Max distance for a connection to be valid. The value 0 (zero) will be read as infinity and thus all nodes not restricted by other constraints will be added as connections. 

A negative value will disable any neighbours to be added. It will completely stop the connection processing to be done, so it can save you processing power if you don\textquotesingle{}t these connections.\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_ad0862813b3ecd1396ab6aa65f49f3910}\label{class_pathfinding_1_1_point_graph_ad0862813b3ecd1396ab6aa65f49f3910}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!nearestNodeDistanceMode@{nearestNodeDistanceMode}}
\index{nearestNodeDistanceMode@{nearestNodeDistanceMode}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{nearestNodeDistanceMode}{nearestNodeDistanceMode}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a60745b93b227c7bb466d228120ee243f}{Node\+Distance\+Mode}} Pathfinding.\+Point\+Graph.\+nearest\+Node\+Distance\+Mode}





Distance query mode. \mbox{[}Open online documentation to see images\mbox{]} In the image above there are a few red nodes. Assume the agent is the orange circle. Using the Node mode the closest point on the graph that would be found would be the node at the bottom center which may not be what you want. Using the Connection mode it will find the closest point on the connection between the two nodes in the top half of the image.

When using the Connection option you may also want to use the Connection option for the \mbox{\hyperlink{class_pathfinding_1_1_seeker}{Seeker}}\textquotesingle{}s Start End Modifier snapping options. This is not strictly necessary, but it most cases it is what you want.

See\+: \mbox{\hyperlink{class_pathfinding_1_1_start_end_modifier_a1a75266e70c393d320cb797c304e9274}{Pathfinding.\+Start\+End\+Modifier.\+exact\+End\+Point}}

See\+: \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a60745b93b227c7bb466d228120ee243f}{Node\+Distance\+Mode}}

If you enable this during runtime, you will need to call \mbox{\hyperlink{class_pathfinding_1_1_point_graph_ac75dfbde3dc85238ea2d5304537cbff9}{Rebuild\+Connection\+Distance\+Lookup}} to make sure some cache data is properly recalculated. If the graph doesn\textquotesingle{}t have any nodes yet or if you are going to scan the graph afterwards then you do not need to do this.\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a1e6a8498de32d784d5b1e98fed0e5aa7}\label{class_pathfinding_1_1_point_graph_a1e6a8498de32d784d5b1e98fed0e5aa7}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!nodes@{nodes}}
\index{nodes@{nodes}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{nodes}{nodes}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_pathfinding_1_1_point_node}{Point\+Node}} \mbox{[}$\,$\mbox{]} Pathfinding.\+Point\+Graph.\+nodes}



All nodes in this graph. Note that only the first \mbox{\hyperlink{class_pathfinding_1_1_point_graph_a45b5ab0eabfd072e976437ce3103d868}{node\+Count}} will be non-\/null. 

You can also use the Get\+Nodes method to get all nodes.\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a08e9052cc4fe68c447d9376fd335af95}\label{class_pathfinding_1_1_point_graph_a08e9052cc4fe68c447d9376fd335af95}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!raycast@{raycast}}
\index{raycast@{raycast}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{raycast}{raycast}}
{\footnotesize\ttfamily bool Pathfinding.\+Point\+Graph.\+raycast = true}



Use raycasts to check connections 

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_ada935a5bb9e71d2b5db0a85c7909e1bd}\label{class_pathfinding_1_1_point_graph_ada935a5bb9e71d2b5db0a85c7909e1bd}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!recursive@{recursive}}
\index{recursive@{recursive}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{recursive}{recursive}}
{\footnotesize\ttfamily bool Pathfinding.\+Point\+Graph.\+recursive = true}



Recursively search for child nodes to the \mbox{\hyperlink{class_pathfinding_1_1_point_graph_af12e3973b6126d65120b04891595f9e9}{root}} 

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_af12e3973b6126d65120b04891595f9e9}\label{class_pathfinding_1_1_point_graph_af12e3973b6126d65120b04891595f9e9}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!root@{root}}
\index{root@{root}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{root}{root}}
{\footnotesize\ttfamily Transform Pathfinding.\+Point\+Graph.\+root}



Childs of this transform are treated as nodes 

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_ab8f69c9b8adbd494054f9badc06c6bce}\label{class_pathfinding_1_1_point_graph_ab8f69c9b8adbd494054f9badc06c6bce}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!searchTag@{searchTag}}
\index{searchTag@{searchTag}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{searchTag}{searchTag}}
{\footnotesize\ttfamily string Pathfinding.\+Point\+Graph.\+search\+Tag}



If no \mbox{\hyperlink{class_pathfinding_1_1_point_graph_af12e3973b6126d65120b04891595f9e9}{root}} is set, all nodes with the tag is used as nodes 

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a191d25a134c7891668b98da78ab06ac9}\label{class_pathfinding_1_1_point_graph_a191d25a134c7891668b98da78ab06ac9}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!thickRaycast@{thickRaycast}}
\index{thickRaycast@{thickRaycast}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{thickRaycast}{thickRaycast}}
{\footnotesize\ttfamily bool Pathfinding.\+Point\+Graph.\+thick\+Raycast}



Use thick raycast 

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a8b80ca07f77c012aafe4171d55fd917c}\label{class_pathfinding_1_1_point_graph_a8b80ca07f77c012aafe4171d55fd917c}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!thickRaycastRadius@{thickRaycastRadius}}
\index{thickRaycastRadius@{thickRaycastRadius}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{thickRaycastRadius}{thickRaycastRadius}}
{\footnotesize\ttfamily float Pathfinding.\+Point\+Graph.\+thick\+Raycast\+Radius = 1}



Thick raycast radius 

\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_ac5bcd5a9d07beca7956657a067597da5}\label{class_pathfinding_1_1_point_graph_ac5bcd5a9d07beca7956657a067597da5}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!use2DPhysics@{use2DPhysics}}
\index{use2DPhysics@{use2DPhysics}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{use2DPhysics}{use2DPhysics}}
{\footnotesize\ttfamily bool Pathfinding.\+Point\+Graph.\+use2\+D\+Physics}



Use the 2D Physics A\+PI 



\doxysubsection{Property Documentation}
\mbox{\Hypertarget{class_pathfinding_1_1_point_graph_a45b5ab0eabfd072e976437ce3103d868}\label{class_pathfinding_1_1_point_graph_a45b5ab0eabfd072e976437ce3103d868}} 
\index{Pathfinding.PointGraph@{Pathfinding.PointGraph}!nodeCount@{nodeCount}}
\index{nodeCount@{nodeCount}!Pathfinding.PointGraph@{Pathfinding.PointGraph}}
\doxysubsubsection{\texorpdfstring{nodeCount}{nodeCount}}
{\footnotesize\ttfamily int Pathfinding.\+Point\+Graph.\+node\+Count\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [protected set]}}



Number of nodes in this graph 



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
Assets/\+Third Party Addons/\+Astar\+Pathfinding\+Project/\+Generators/Point\+Generator.\+cs\end{DoxyCompactItemize}
